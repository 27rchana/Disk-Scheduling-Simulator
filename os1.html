<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Disk Scheduling Simulator</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  font-family: 'Poppins', sans-serif;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 100vh;
  background: radial-gradient(circle at 20% 20%, #0a0f1f, #00111f 80%);
  color: #fff;
}
#bgCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
}
.container {
  position: relative;
  z-index: 1;
  margin: 20px auto 60px auto;
  width: 90%;
  max-width: 950px;
  background: rgba(10, 10, 10, 0.4);
  border-radius: 20px;
  padding: 25px;
  text-align: center;
  box-shadow: 0 8px 20px rgba(0,0,0,0.6);
  backdrop-filter: blur(8px);
}
h1 {
  font-size: 1.8em;
  margin-bottom: 12px;
  color: #81d4fa;
  text-shadow: 0 0 10px rgba(0,200,255,0.5);
}
form {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
  gap: 10px;
  margin-bottom: 15px;
}
input, select, button {
  border: none;
  border-radius: 8px;
  padding: 6px 8px;
  font-size: 0.9em;
  font-family: 'Poppins', sans-serif;
  transition: 0.3s;
}
input, select {
  width: 110px;
  text-align: center;
}
button {
  background-color: #00b4d8;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
}
button:hover {
  background-color: #0077b6;
  transform: scale(1.05);
}
#addBtn {
  background-color: #48cae4;
}
#graph {
  width: 100%;
  height: 250px;
  background-color: rgba(255,255,255,0.05);
  border-radius: 12px;
  margin-top: 15px;
}
#output {
  margin-top: 15px;
  background: rgba(0,0,0,0.4);
  padding: 15px;
  border-radius: 12px;
  font-size: 0.95em;
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 1s ease, transform 1s ease;
}
#output.show {
  opacity: 1;
  transform: translateY(0);
}
#descBox {
  margin-top: 25px;
  padding: 15px;
  border-radius: 12px;
  background: rgba(0,0,0,0.5);
  color: #cfe9ff;
  line-height: 1.6;
  box-shadow: 0 0 15px rgba(0,255,255,0.1);
  font-size: 0.95em;
}
#descBox a { color: #00eaff; text-decoration: none; }
#descBox a:hover { text-decoration: underline; }
</style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<div class="container">
<h1>Disk Scheduling Simulator</h1>
<form id="diskForm">
  <div id="requestContainer">
    <label>Requests</label><br>
    <input type="number" class="req" value="180">
    <input type="number" class="req" value="40">
    <input type="number" class="req" value="210">
    <input type="number" class="req" value="65">
    <input type="number" class="req" value="20">
    <input type="number" class="req" value="130">
    <input type="number" class="req" value="195">
  </div>
  <button type="button" id="addBtn">+</button>
  <div>
    <label>Head</label><br>
    <input type="number" id="head" value="125">
  </div>
  <div>
    <label>Prev</label><br>
    <input type="number" id="prev" value="100">
  </div>
  <div>
    <label>Max Cyl</label><br>
    <input type="number" id="maxCyl" value="249">
  </div>
  <div>
    <label>Algorithm</label><br>
    <select id="algo">
      <option value="FCFS">FCFS</option>
      <option value="SSTF">SSTF</option>
      <option value="SCAN">SCAN</option>
      <option value="CSCAN">CSCAN</option>
      <option value="LOOK">LOOK</option>
      <option value="CLOOK">CLOOK</option>
    </select>
  </div>
  <div style="align-self: flex-end;">
    <button type="button" id="runBtn">Run</button>
  </div>
</form>
<canvas id="graph"></canvas>
<div id="output"></div>
<div id="descBox"></div>
</div>

<script>
// ---------- CYBERPUNK BACKGROUND ----------
const bg = document.getElementById('bgCanvas');
const ctxBg = bg.getContext('2d');
bg.width = window.innerWidth;
bg.height = window.innerHeight;
let mouse = { x: bg.width/2, y: bg.height/2 };
document.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; });
let lines = Array.from({length:35},()=>({
  x:Math.random()*bg.width,
  y:Math.random()*bg.height,
  len:Math.random()*80+50,
  speed:Math.random()*2+0.5,
  hue:Math.floor(Math.random()*60+180)
}));
function animateBg(){
  ctxBg.fillStyle='rgba(0,0,0,0.1)';
  ctxBg.fillRect(0,0,bg.width,bg.height);
  lines.forEach(l=>{
    ctxBg.beginPath();
    ctxBg.moveTo(l.x,l.y);
    ctxBg.lineTo(l.x+l.len*Math.cos(mouse.x/500),l.y+l.len*Math.sin(mouse.y/500));
    ctxBg.strokeStyle=`hsl(${l.hue}, 80%, 60%)`;
    ctxBg.lineWidth=1.2;
    ctxBg.stroke();
    l.y+=l.speed;
    if(l.y>bg.height) l.y=0;
  });
  requestAnimationFrame(animateBg);
}
animateBg();

// ---------- ADD REQUEST BOX ----------
document.getElementById('addBtn').addEventListener('click', ()=>{
  const container=document.getElementById('requestContainer');
  const input=document.createElement('input');
  input.type='number'; input.className='req'; input.placeholder='e.g., 120';
  container.appendChild(document.createElement('br'));
  container.appendChild(input);
});

// ---------- DISK SIMULATION ----------
document.getElementById('runBtn').addEventListener('click', simulate);

function simulate(){
  const reqs=[...document.querySelectorAll('.req')].map(i=>parseInt(i.value)).filter(v=>!isNaN(v));
  const head=parseInt(document.getElementById("head").value);
  const prev=parseInt(document.getElementById("prev").value);
  const max=parseInt(document.getElementById("maxCyl").value);
  const algo=document.getElementById("algo").value;

  if(reqs.length===0){alert("Enter at least one request!"); return;}

  let order=[],total=0;
  const sorted=[...reqs].sort((a,b)=>a-b);
  const direction=head>prev?'up':'down';
  const abs=x=>x<0?-x:x;

  if(algo==="FCFS") order=reqs;
  else if(algo==="SSTF"){
    let temp=[...reqs], pos=head;
    while(temp.length>0){
      let idx=0,min=9999;
      for(let i=0;i<temp.length;i++){
        let d=abs(temp[i]-pos);
        if(d<min){min=d;idx=i;}
      }
      order.push(temp[idx]);
      pos=temp[idx];
      temp.splice(idx,1);
    }
  }
  else if(algo==="SCAN"){
    const left=sorted.filter(x=>x<head), right=sorted.filter(x=>x>=head);
    order=(direction==='up')? right.concat(left.reverse()): left.reverse().concat(right);
  }
  else if(algo==="CSCAN"){
    const left=sorted.filter(x=>x<head), right=sorted.filter(x=>x>=head);
    order=(direction==='up')? right.concat([max,0]).concat(left): left.reverse().concat([0,max]).concat(right.reverse());
  }
  else if(algo==="LOOK"){
    const left=sorted.filter(x=>x<head), right=sorted.filter(x=>x>=head);
    order=(direction==='up')? right.concat(left.reverse()): left.reverse().concat(right);
  }
  else if(algo==="CLOOK"){
    const left=sorted.filter(x=>x<head), right=sorted.filter(x=>x>=head);
    order=(direction==='up')? right.concat(left): left.reverse().concat(right.reverse());
  }

  let pos=head;
  for(let i=0;i<order.length;i++){ total+=abs(order[i]-pos); pos=order[i]; }

  const out=document.getElementById('output');
  out.classList.remove('show');
  out.innerHTML=`<b>${algo}</b> Order:<br>${[head,...order].join(" → ")}<br><b>Total Movement:</b> ${total} cylinders`;
  setTimeout(()=>out.classList.add('show'),200);

  drawAnimatedGraph([head,...order], max);
  showDescription(algo);
}

function drawAnimatedGraph(points,max){
  const canvas=document.getElementById("graph");
  const ctx=canvas.getContext("2d");
  const width=canvas.width=canvas.offsetWidth;
  const height=canvas.height=canvas.offsetHeight;
  ctx.clearRect(0,0,width,height);
  const step=width/(points.length-1);
  const min=0,maxC=max;
  let i=0;
  const duration=700;
  let startTime=null;
  let x1,y1,x2,y2;

  function drawSegment(timestamp){
    if(!startTime) startTime=timestamp;
    const progress=Math.min((timestamp-startTime)/duration,1);
    const curX=x1+(x2-x1)*progress;
    const curY=y1+(y2-y1)*progress;

    ctx.strokeStyle="#00eaff";
    ctx.lineWidth=1.3; /* thinner line */
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(curX,curY);
    ctx.stroke();

    ctx.beginPath();
    ctx.fillStyle="#90e0ef";
    ctx.arc(curX,curY,4,0,Math.PI*2);
    ctx.fill();

    if(progress<1){
      requestAnimationFrame(drawSegment);
    } else {
      i++;
      if(i<points.length-1){
        startTime=null;
        x1=x2; y1=y2;
        x2=(i+1)*step;
        y2=height - ((points[i+1]-min)/(maxC-min))*height*0.9 - 10;
        requestAnimationFrame(drawSegment);
      }
    }
  }

  x1=0;
  y1=height - ((points[0]-min)/(maxC-min))*height*0.9 - 10;
  x2=step;
  y2=height - ((points[1]-min)/(maxC-min))*height*0.9 - 10;
  requestAnimationFrame(drawSegment);
}

// ---------- ALGORITHM DESCRIPTIONS ----------
function showDescription(algo){
  const descBox=document.getElementById('descBox');
  const info={
    FCFS:`<b>FCFS (First Come First Serve):</b><br>
    Requests are processed in the order they arrive. It’s simple but may cause long waiting times.<br>
    <a href="https://www.geeksforgeeks.org/fcfs-disk-scheduling-algorithms/" target="_blank">Learn more</a>`,
    SSTF:`<b>SSTF (Shortest Seek Time First):</b><br>
    The request closest to the current head position is served first. Reduces seek time but may cause starvation.<br>
    <a href="https://www.geeksforgeeks.org/shortest-seek-time-first-sstf-disk-scheduling-algorithm/" target="_blank">Learn more</a>`,
    SCAN:`<b>SCAN (Elevator Algorithm):</b><br>
    The head moves in one direction, servicing requests, then reverses direction at the end. Works like an elevator.<br>
    <a href="https://www.geeksforgeeks.org/scan-elevator-disk-scheduling-algorithms/" target="_blank">Learn more</a>`,
    CSCAN:`<b>CSCAN (Circular SCAN):</b><br>
    The head moves in one direction and, after reaching the end, jumps back to the start without servicing on the return.<br>
    <a href="https://www.geeksforgeeks.org/c-scan-disk-scheduling-algorithm/" target="_blank">Learn more</a>`,
    LOOK:`<b>LOOK:</b><br>
    Like SCAN, but the head only goes as far as the last request in each direction before reversing.<br>
    <a href="https://www.geeksforgeeks.org/look-disk-scheduling-algorithm/" target="_blank">Learn more</a>`,
    CLOOK:`<b>CLOOK (Circular LOOK):</b><br>
    Like CSCAN, but the head jumps back to the lowest request instead of the start of the disk.<br>
    <a href="https://www.geeksforgeeks.org/c-look-disk-scheduling-algorithm/" target="_blank">Learn more</a>`
  };
  descBox.innerHTML = info[algo];
}
</script>

<!-- Hidden C Reference -->
<pre style="display:none">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
int requests[100], n, head, prev, maxCyl, total=0;
void *fcfs(void *arg){
 int pos=head;
 for(int i=0;i&lt;n;i++){ total+=abs(requests[i]-pos); pos=requests[i]; }
 printf("FCFS Total Movement: %d\\n", total);
 return NULL;
}
int main(){
 printf("Enter number of requests: "); scanf("%d",&n);
 for(int i=0;i&lt;n;i++) scanf("%d",&requests[i]);
 printf("Enter head, prev, max: "); scanf("%d%d%d",&head,&prev,&maxCyl);
 pthread_t t; pthread_create(&t,NULL,fcfs,NULL); pthread_join(t,NULL);
 return 0;
}
</pre>
</body>
</html>
